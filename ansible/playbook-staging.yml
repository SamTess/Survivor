---
- name: Deploy Survivor Application to Staging
  hosts: survivor_staging
  vars_files:
    - config.yml
  tags:
    - deploy
    - staging
  vars:
    deploy_env: "staging"
    git_branch: "{{ repository.git_branch_staging }}"
    compose_file: "{{ docker.staging_compose_file }}"
    app_port: "{{ docker.staging_port }}"
    env_file: "{{ env_files.staging_env_file }}"
  tasks:
    - name: Create application directory
      file:
        path: "{{ repository.app_directory }}"
        state: directory
        mode: '0755'

    - name: Clone/Update repository (staging branch)
      git:
        repo: "{{ repository.git_url }}"
        dest: "{{ repository.app_directory }}"
        version: "{{ git_branch }}"
        depth: 1
        force: yes
        update: yes
      register: git_clone_staging

    - name: Copy staging environment file
      template:
        src: "{{ env_file }}.j2"
        dest: "{{ repository.app_directory }}/Docker/.env"
        mode: '0644'
        backup: yes
      when: env_file is defined
      register: env_file_staging
      ignore_errors: yes

    - name: Ensure scripts directory exists
      file:
        path: "{{ repository.app_directory }}/scripts"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Copy SSL initialization script
      copy:
        src: "{{ playbook_dir }}/../scripts/init-ssl.sh"
        dest: "{{ repository.app_directory }}/scripts/init-ssl.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Check if compose file exists (staging)
      stat:
        path: "{{ repository.app_directory }}/Docker/{{ compose_file }}"
      register: compose_file_check_staging

    - name: Wait for DNS propagation before SSL setup
      shell: |
        echo "Checking DNS propagation for {{ staging.domain }}..."
        echo "Expected IP: {{ ansible_host }}"
        dig +short @8.8.8.8 {{ staging.domain }} | grep -q "{{ ansible_host }}"
      register: dns_propagation_check
      until: dns_propagation_check.rc == 0
      retries: 30
      delay: 10
      when: compose_file_check_staging.stat.exists

    - name: Retry DNS propagation check after DNS update
      shell: |
        echo "Retrying DNS propagation check after DNS update..."
        dig +short @8.8.8.8 {{ staging.domain }} | grep -q "{{ ansible_host }}"
      register: dns_retry_check
      until: dns_retry_check.rc == 0
      retries: 12
      delay: 10
      when:
        - compose_file_check_staging.stat.exists
        - dns_propagation_check is failed

    - name: Display DNS propagation status
      debug:
        msg: |
          ✅ DNS propagation completed!
          Domain: {{ staging.domain }}
          Expected IP: {{ ansible_host }}
          DNS check passed after {{ (dns_propagation_check.attempts | default(0)) + (dns_retry_check.attempts | default(0)) }} attempts
          {% if dns_propagation_check is failed and dns_retry_check is succeeded %}
          DNS update was required
          {% endif %}
      when: dns_propagation_check is succeeded or dns_retry_check is succeeded

    - name: Debug - Show compose file check result
      debug:
        msg: |
          Compose file path: {{ repository.app_directory }}/Docker/{{ compose_file }}
          File exists: {{ compose_file_check_staging.stat.exists | default('undefined') }}
          Looking for: docker-compose.https.yml

    - name: Stop existing Docker containers (staging)
      community.docker.docker_compose_v2:
        project_src: "{{ repository.app_directory }}/Docker"
        files:
          - "{{ compose_file }}"
        state: absent
        remove_orphans: yes
      when: compose_file_check_staging.stat.exists
      ignore_errors: yes

    - name: Run SSL initialization script (handles everything)
      shell: |
        cd {{ repository.app_directory }}/Docker
        ../scripts/init-ssl.sh {{ staging.ssl_staging | default(1) | int }} {{ staging.domain }}
      become_user: "{{ ansible_user }}"
      register: ssl_setup_result
      when: compose_file_check_staging.stat.exists
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      ignore_errors: yes

    - name: Retry SSL setup if it failed (DNS propagation issues)
      shell: |
        cd {{ repository.app_directory }}/Docker
        ../scripts/init-ssl.sh {{ staging.ssl_staging | default(1) | int }} {{ staging.domain }}
      become_user: "{{ ansible_user }}"
      register: ssl_retry_result
      when:
        - compose_file_check_staging.stat.exists
        - ssl_setup_result is failed or ssl_setup_result.rc != 0
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      ignore_errors: yes

    - name: Check SSL certificate status
      shell: |
        cd {{ repository.app_directory }}/Docker
        if [ -f "./certbot-etc/live/{{ staging.domain }}/fullchain.pem" ]; then
          echo "Certificate found - checking validity..."
          openssl x509 -in ./certbot-etc/live/{{ staging.domain }}/fullchain.pem -text -noout | grep -E "(Issuer:|Not Before:|Not After:)"
          echo "Certificate issuer check:"
          openssl x509 -in ./certbot-etc/live/{{ staging.domain }}/fullchain.pem -text -noout | grep "Issuer:" | grep -q "R3" && echo "✅ Production certificate" || echo "🧪 Staging certificate (Let's Encrypt)"
        else
          echo "❌ No certificate found"
        fi
      register: ssl_status_check
      when: compose_file_check_staging.stat.exists
      ignore_errors: yes
      changed_when: false

    - name: Display SSL certificate information
      debug:
        msg: |
          SSL Certificate Status:
          {{ ssl_status_check.stdout | default('No certificate information available') }}
          {% if staging.ssl_staging | default(true) %}
          Note: Currently using staging certificates. To switch to production:
          1. Ensure DNS propagation is complete globally (check multiple DNS servers)
          2. Run: ansible-playbook playbook-staging.yml --tags ssl-production
          {% endif %}
      when: ssl_status_check is defined

    - name: Upgrade to production SSL certificates (when DNS is fully propagated)
      shell: |
        cd {{ repository.app_directory }}/Docker
        ../scripts/init-ssl.sh 0 {{ staging.domain }}
      become_user: "{{ ansible_user }}"
      register: ssl_production_result
      when:
        - compose_file_check_staging.stat.exists
        - staging.ssl_staging | default(true) == false
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin"
      tags:
        - ssl-production
        - never
      ignore_errors: yes

    - name: Display production SSL upgrade results
      debug:
        msg: "{{ ssl_production_result.stdout_lines }}"
      when: ssl_production_result is defined
      tags:
        - ssl-production
        - never

    - name: Wait for services to stabilize after SSL setup
      pause:
        seconds: 10
      when: compose_file_check_staging.stat.exists

    - name: Check if migration files exist (staging)
      command: docker compose -f docker-compose.https.yml exec -T web sh -c "ls -la prisma/migrations/ 2>/dev/null | wc -l"
      args:
        chdir: "{{ repository.app_directory }}/Docker"
      when: compose_file_check_staging.stat.exists
      register: staging_migration_files_check
      ignore_errors: yes

    - name: Create database schema from Prisma schema (staging - first time)
      command: docker compose -f docker-compose.https.yml exec -T web npx prisma db push --accept-data-loss
      args:
        chdir: "{{ repository.app_directory }}/Docker"
      when:
        - compose_file_check_staging.stat.exists
        - staging_migration_files_check.stdout is defined
        - staging_migration_files_check.stdout | int <= 2
      register: staging_db_push_result
      ignore_errors: yes

    - name: Run Prisma database migration (staging - if migrations exist)
      command: docker compose -f docker-compose.https.yml exec -T web npx prisma migrate deploy
      args:
        chdir: "{{ repository.app_directory }}/Docker"
      when:
        - compose_file_check_staging.stat.exists
        - staging_migration_files_check.stdout is defined
        - staging_migration_files_check.stdout | int > 2
      register: staging_migration_result
      ignore_errors: yes

    - name: Generate Prisma client (staging)
      command: docker compose -f docker-compose.https.yml exec -T web npx prisma generate
      args:
        chdir: "{{ repository.app_directory }}/Docker"
      when: compose_file_check_staging.stat.exists
      register: staging_generate_result
      ignore_errors: yes

    - name: Display migration status (staging)
      debug:
        msg: |
          Staging migration status:
          {% if staging_db_push_result is defined and staging_db_push_result.rc is defined %}
          DB Push (first time): {{ 'SUCCESS' if staging_db_push_result.rc == 0 else 'FAILED' }}
          {% if staging_db_push_result.rc != 0 %}
          DB Push error: {{ staging_db_push_result.stderr | default('Unknown error') }}
          {% endif %}
          {% elif staging_db_push_result is defined %}
          DB Push (first time): SKIPPED or FAILED (no rc)
          {% else %}
          DB Push (first time): NOT RUN
          {% endif %}
          {% if staging_migration_result is defined and staging_migration_result.rc is defined %}
          Migration: {{ 'SUCCESS' if staging_migration_result.rc == 0 else 'FAILED' }}
          {% if staging_migration_result.rc != 0 %}
          Migration error: {{ staging_migration_result.stderr | default('Unknown error') }}
          {% endif %}
          {% elif staging_migration_result is defined %}
          Migration: SKIPPED or FAILED (no rc)
          {% else %}
          Migration: NOT RUN
          {% endif %}
          {% if staging_generate_result is defined and staging_generate_result.rc is defined %}
          Generate: {{ 'SUCCESS' if staging_generate_result.rc == 0 else 'FAILED' }}
          {% if staging_generate_result.rc != 0 %}
          Generate error: {{ staging_generate_result.stderr | default('Unknown error') }}
          {% endif %}
          {% elif staging_generate_result is defined %}
          Generate: SKIPPED or FAILED (no rc)
          {% else %}
          Generate: NOT RUN
          {% endif %}
      when: compose_file_check_staging.stat.exists

    - name: Wait for staging application to be ready
      uri:
        url: "https://{{ staging.domain }}/health"
        method: GET
        status_code: 200
        timeout: 10
        validate_certs: no
      register: staging_health_check
      until: staging_health_check.status == 200
      retries: 30
      delay: 10
      when: compose_file_check_staging.stat.exists
      ignore_errors: yes

    - name: Check if staging containers are running (fallback health check)
      command: docker ps --filter "name={{ application.app_name }}" --format "table {% raw %}{{.Names}}\t{{.Status}}{% endraw %}"
      register: staging_container_status
      when: staging_health_check is failed or staging_health_check is skipped
      changed_when: false

    - name: Display staging deployment status
      debug:
        msg: |
          🎉 Staging deployment completed!
          URL: https://{{ staging.domain }}
          Branch: {{ git_branch }}
          Health check: {{ 'PASSED' if (staging_health_check.status is defined and staging_health_check.status == 200) else 'FAILED/SKIPPED' }}
          SSL Setup: {{ 'COMPLETED' if (ssl_setup_result is defined and ssl_setup_result.rc is defined and ssl_setup_result.rc == 0) else 'FAILED/SKIPPED' }}
          {% if staging_container_status is defined and staging_container_status.stdout is defined %}
          Container status: {{ staging_container_status.stdout }}
          {% endif %}

    - name: Check if staging containers are running before API call
      command: docker ps --format "{% raw %}{{.Names}}\t{{.Status}}{% endraw %}"
      register: staging_running_check
      when: staging_deploy_result is defined
      changed_when: false

    - name: Force external data sync via API
      uri:
        url: "https://{{ staging.domain }}/api/sync/external"
        method: POST
        body_format: json
        body: "{}"
        headers:
          Content-Type: "application/json"
        status_code: [200, 201, 202]
        timeout: 30
        validate_certs: no
      register: sync_api_result
      when:
        - staging_deploy_result is defined
        - staging_running_check.stdout is defined
        - staging_running_check.stdout != ""
        - "'Up' in staging_running_check.stdout or 'healthy' in staging_running_check.stdout"
      ignore_errors: yes

    - name: Display sync API result
      debug:
        msg: |
          External sync API call result:
          {% if sync_api_result is defined and sync_api_result.status is defined %}
          Status: {{ sync_api_result.status }}
          Response: {{ sync_api_result.json | default('No JSON response') }}
          {% elif sync_api_result is defined %}
          Result: FAILED - {{ sync_api_result.msg | default('Unknown error') }}
          {% else %}
          Result: SKIPPED (containers not running or deployment unchanged)
          {% endif %}
      when: staging_deploy_result is defined

    - name: Setup basic log rotation for Docker containers
      copy:
        dest: /etc/logrotate.d/docker-containers
        mode: '0644'
        content: |
          /var/lib/docker/containers/*/*.log {
              rotate 7
              daily
              compress
              size=1M
              missingok
              delaycompress
              copytruncate
          }
      ignore_errors: yes